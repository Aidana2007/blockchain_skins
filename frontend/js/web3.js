import CONFIG from './config.js';import { Utils } from './utils.js';export const Web3Service = {  provider: null,  signer: null,  account: null,  contracts: {},  async init() {    if (typeof window.ethereum !== 'undefined') {      this.provider = new ethers.BrowserProvider(window.ethereum);      console.log('✅ MetaMask detected');      return true;    } else {      console.error('❌ MetaMask not detected');      Utils.showToast('Please install MetaMask!', 'error');      return false;    }  },  async connect() {    try {      if (!this.provider) {        await this.init();      }      await window.ethereum.request({ method: 'eth_requestAccounts' });      this.signer = await this.provider.getSigner();      const address = await this.signer.getAddress();      this.account = address;      await this.checkNetwork();      this.initContracts();      localStorage.setItem(CONFIG.STORAGE_KEYS.WALLET_ADDRESS, address);      this.setupEventListeners();      Utils.showToast('Wallet connected!', 'success');      return address;    } catch (error) {      console.error('Connection error:', error);      Utils.showToast('Failed to connect wallet', 'error');      throw error;    }  },  disconnect() {    this.signer = null;    this.account = null;    this.contracts = {};    localStorage.removeItem(CONFIG.STORAGE_KEYS.WALLET_ADDRESS);    Utils.showToast('Wallet disconnected', 'info');  },  async getAddress() {    if (!this.signer) return null;    return await this.signer.getAddress();  },  async checkNetwork() {    const network = await this.provider.getNetwork();    const chainId = Number(network.chainId);    if (chainId !== CONFIG.NETWORK.CHAIN_ID) {      await this.switchNetwork();    }  },  async switchNetwork() {    try {      await window.ethereum.request({        method: 'wallet_switchEthereumChain',        params: [{ chainId: `0x${CONFIG.NETWORK.CHAIN_ID.toString(16)}` }],      });    } catch (switchError) {      if (switchError.code === 4902) {        await this.addNetwork();      } else {        throw switchError;      }    }  },  async addNetwork() {    await window.ethereum.request({      method: 'wallet_addEthereumChain',      params: [{        chainId: `0x${CONFIG.NETWORK.CHAIN_ID.toString(16)}`,        chainName: CONFIG.NETWORK.NAME,        rpcUrls: [CONFIG.NETWORK.RPC_URL],        nativeCurrency: {          name: 'ETH',          symbol: 'ETH',          decimals: 18        }      }],    });  },  initContracts() {    const steamTokenAbi = [      "function balanceOf(address owner) view returns (uint256)",      "function transfer(address to, uint256 amount) returns (bool)",      "function approve(address spender, uint256 amount) returns (bool)",      "function allowance(address owner, address spender) view returns (uint256)",      "function symbol() view returns (string)",      "function decimals() view returns (uint8)"    ];    const crowdfundingAbi = [      "function createCampaign(string title, uint256 goal, uint256 durationInDays) returns (uint256)",      "function fundCampaign(uint256 campaignId) payable",      "function finalizeCampaign(uint256 campaignId)",      "function getCampaign(uint256 campaignId) view returns (string, uint256, uint256, uint256, address, bool, bool)",      "function campaignCount() view returns (uint256)",      "function getContribution(uint256 campaignId, address contributor) view returns (uint256)"    ];    const skinPaymentAbi = [      "function buySkin(uint256 skinId, uint256 price)",      "function calculatePrice(uint256 basePrice) view returns (uint256, uint256)"    ];    this.contracts.steamToken = new ethers.Contract(      CONFIG.CONTRACTS.STEAM_TOKEN,      steamTokenAbi,      this.signer    );    this.contracts.crowdfunding = new ethers.Contract(      CONFIG.CONTRACTS.CROWDFUNDING,      crowdfundingAbi,      this.signer    );    this.contracts.skinPayment = new ethers.Contract(      CONFIG.CONTRACTS.SKIN_PAYMENT,      skinPaymentAbi,      this.signer    );  },  setupEventListeners() {    window.ethereum.on('accountsChanged', (accounts) => {      if (accounts.length === 0) {        this.disconnect();        window.location.reload();      } else {        window.location.reload();      }    });    window.ethereum.on('chainChanged', () => {      window.location.reload();    });  },  async getETHBalance(address) {    const balance = await this.provider.getBalance(address);    return ethers.formatEther(balance);  },  async getSTMBalance(address) {    try {      const steamTokenAbi = [        "function balanceOf(address owner) view returns (uint256)"      ];      const tokenContract = new ethers.Contract(        CONFIG.CONTRACTS.STEAM_TOKEN,        steamTokenAbi,        this.provider      );      const balance = await tokenContract.balanceOf(address);      return ethers.formatEther(balance);    } catch (error) {      console.error('Error getting STM balance:', error);      return '0';    }  },  async transferTokens(toAddress, amount) {    try {      if (!this.signer) {        throw new Error('Wallet not connected');      }      if (!this.contracts.steamToken) {        this.initContracts();      }      const amountWei = ethers.parseEther(amount.toString());      const tx = await this.contracts.steamToken.transfer(toAddress, amountWei);      Utils.showToast('Transaction submitted...', 'info');      const receipt = await tx.wait();      Utils.showToast('Tokens transferred successfully!', 'success');      return receipt;    } catch (error) {      console.error('Transfer error:', error);      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async createCampaign(title, goalETH, durationDays) {    try {      const goalWei = ethers.parseEther(goalETH.toString());      const tx = await this.contracts.crowdfunding.createCampaign(        title,        goalWei,        durationDays      );      Utils.showToast('Transaction submitted...', 'info');      const receipt = await tx.wait();      Utils.showToast('Campaign created!', 'success');      return receipt;    } catch (error) {      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async fundCampaign(campaignId, amountETH) {    try {      const amountWei = ethers.parseEther(amountETH.toString());      const tx = await this.contracts.crowdfunding.fundCampaign(        campaignId,        { value: amountWei }      );      Utils.showToast('Transaction submitted...', 'info');      const receipt = await tx.wait();      Utils.showToast('Campaign funded! STM tokens received!', 'success');      return receipt;    } catch (error) {      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async finalizeCampaign(campaignId) {    try {      const tx = await this.contracts.crowdfunding.finalizeCampaign(campaignId);      Utils.showToast('Transaction submitted...', 'info');      const receipt = await tx.wait();      Utils.showToast('Campaign finalized!', 'success');      return receipt;    } catch (error) {      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async getCampaign(campaignId) {    const data = await this.contracts.crowdfunding.getCampaign(campaignId);    return {      title: data[0],      goal: ethers.formatEther(data[1]),      deadline: new Date(Number(data[2]) * 1000),      amountRaised: ethers.formatEther(data[3]),      creator: data[4],      finalized: data[5],      cancelled: data[6]    };  },  async approveSTM(amountSTM) {    try {      if (!this.signer) {        throw new Error('Wallet not connected');      }      if (!this.contracts.steamToken) {        this.initContracts();      }      const amountWei = ethers.parseEther(amountSTM.toString());      const tx = await this.contracts.steamToken.approve(        CONFIG.CONTRACTS.SKIN_PAYMENT,        amountWei      );      Utils.showToast('Approving STM tokens...', 'info');      const receipt = await tx.wait();      Utils.showToast('STM tokens approved!', 'success');      return receipt;    } catch (error) {      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async checkAllowance(ownerAddress) {    try {      if (!this.contracts.steamToken) {        this.initContracts();      }      const allowance = await this.contracts.steamToken.allowance(        ownerAddress,        CONFIG.CONTRACTS.SKIN_PAYMENT      );      return ethers.formatEther(allowance);    } catch (error) {      console.error('Error checking allowance:', error);      return '0';    }  },  async buySkin(skinId, priceSTM) {    try {      if (!this.signer) {        throw new Error('Wallet not connected');      }      if (!this.contracts.skinPayment) {        this.initContracts();      }      if (!this.contracts.skinPayment) {        throw new Error('Contract not initialized');      }      console.log('Buying skin:', skinId, 'Price:', priceSTM);      const priceWei = ethers.parseEther(priceSTM.toString());      Utils.showToast('Checking token allowance...', 'info');      const allowance = await this.checkAllowance(this.account);      if (parseFloat(allowance) < priceSTM) {        Utils.showToast('Approving STM tokens...', 'info');        await this.approveSTM(priceSTM);      }      Utils.showToast('Purchasing skin...', 'info');      const tx = await this.contracts.skinPayment.buySkin(skinId, priceWei);      if (!tx || !tx.wait) {        throw new Error('Invalid transaction object');      }      const receipt = await tx.wait();      Utils.showToast('Skin purchased! Ownership updated.', 'success');      return receipt;    } catch (error) {      console.error('Buy skin error:', error);      const message = Utils.parseWeb3Error(error);      Utils.showToast(message, 'error');      throw error;    }  },  async addTokenToWallet() {    try {      await window.ethereum.request({        method: 'wallet_watchAsset',        params: {          type: 'ERC20',          options: {            address: CONFIG.CONTRACTS.STEAM_TOKEN,            symbol: CONFIG.TOKEN.SYMBOL,            decimals: CONFIG.TOKEN.DECIMALS,          },        },      });      Utils.showToast('Token added to MetaMask!', 'success');    } catch (error) {      console.error('Error adding token:', error);    }  }};if (typeof module !== 'undefined' && module.exports) {  module.exports = Web3Service;}