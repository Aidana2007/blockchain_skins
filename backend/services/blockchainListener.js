const { ethers } = require('ethers');const { getContract, addresses, provider } = require('../config/blockchain');const Campaign = require('../models/Campaign');const Skin = require('../models/Skin');const User = require('../models/User');let crowdfundingContract;let skinPaymentContract;let isListening = false;const processedTransactions = new Set();let startBlock = 0;function initializeContracts() {  try {    crowdfundingContract = getContract('crowdfunding');    skinPaymentContract = getContract('skinPayment');    console.log('âœ… Blockchain listener contracts initialized');  } catch (error) {    console.error('âŒ Failed to initialize contracts:', error.message);    throw error;  }}function listenToCampaignCreated() {  crowdfundingContract.on(    'CampaignCreated',    async (campaignId, title, goal, deadline, creator, event) => {      try {        const eventBlock = event.log?.blockNumber || event.blockNumber;        if (eventBlock && startBlock && eventBlock < startBlock) {          console.log('â­ï¸  Ignoring historical event from block', eventBlock);          return;        }        const txHash = event.log?.transactionHash || event.transactionHash;        if (txHash && processedTransactions.has(txHash)) {          console.log('â­ï¸  Skipping already processed transaction:', txHash);          return;        }        if (txHash) {          processedTransactions.add(txHash);        }        console.log('\nðŸŽ¯ CampaignCreated event detected');        console.log('Campaign ID:', campaignId.toString());        console.log('Title:', title);        console.log('Creator:', creator);        console.log('TX Hash:', txHash);        console.log('Block:', eventBlock);        const blockchainId = Number(campaignId);        const goalEth = Number(ethers.formatEther(goal));        const deadlineDate = new Date(Number(deadline) * 1000);        const creatorLower = creator.toLowerCase();        const upsertResult = await Campaign.updateOne(          { blockchainId },          {            $setOnInsert: {              title,              goal: goalEth,              deadline: deadlineDate,              creator: null,               creatorWalletAddress: creatorLower,              blockchainId,              status: 'Active',              amountRaised: 0            }          },          { upsert: true }        );        if (upsertResult.upsertedCount > 0) {          const user = await User.findOne({ walletAddress: creatorLower });          if (user) {            user.createdCampaigns.push(upsertResult.upsertedId._id);            await user.save();          }          console.log('âœ… Campaign saved to MongoDB (listener upsert):', upsertResult.upsertedId._id);        } else {          console.log('âœ… Campaign already exists in MongoDB, skipping upsert');        }      } catch (error) {        console.error('âŒ Error processing CampaignCreated event:', error);      }    }  );  console.log('ðŸ‘‚ Listening to CampaignCreated events...');}function listenToCampaignFunded() {  crowdfundingContract.on(    'CampaignFunded',    async (campaignId, contributor, amount, tokensRewarded, event) => {      try {        const eventBlock = event.log?.blockNumber || event.blockNumber;        if (eventBlock && startBlock && eventBlock < startBlock) {          console.log('â­ï¸  Ignoring historical event from block', eventBlock);          return;        }        const txHash = event.log?.transactionHash || event.transactionHash;        if (txHash && processedTransactions.has(txHash)) {          console.log('â­ï¸  Skipping already processed transaction:', txHash);          return;        }        if (txHash) {          processedTransactions.add(txHash);        }        console.log('\nðŸ’° CampaignFunded event detected');        console.log('Campaign ID:', campaignId.toString());        console.log('Contributor:', contributor);        console.log('Amount:', ethers.formatEther(amount), 'ETH');        console.log('Tokens Rewarded:', ethers.formatEther(tokensRewarded), 'STM');        console.log('TX Hash:', txHash);        const campaign = await Campaign.findOne({           blockchainId: Number(campaignId)         });        if (!campaign) {          console.warn('âš ï¸  Campaign not found in MongoDB');          return;        }        let user = await User.findOne({           walletAddress: contributor.toLowerCase()         });        await campaign.addContribution(          user ? user._id : null,          contributor.toLowerCase(),          Number(ethers.formatEther(amount)),          Number(ethers.formatEther(tokensRewarded))        );        if (user) {          user.contributedCampaigns.push({            campaignId: campaign._id,            amount: Number(ethers.formatEther(amount)),            contributedAt: new Date()          });          await user.save();        }        console.log('âœ… Contribution recorded in MongoDB');      } catch (error) {        console.error('âŒ Error processing CampaignFunded event:', error);      }    }  );  console.log('ðŸ‘‚ Listening to CampaignFunded events...');}function listenToCampaignFinalized() {  crowdfundingContract.on(    'CampaignFinalized',    async (campaignId, totalRaised, creatorAmount, platformFee, event) => {      try {        const eventBlock = event.log?.blockNumber || event.blockNumber;        if (eventBlock && startBlock && eventBlock < startBlock) {          console.log('â­ï¸  Ignoring historical event from block', eventBlock);          return;        }        const txHash = event.log?.transactionHash || event.transactionHash;        if (txHash && processedTransactions.has(txHash)) {          console.log('â­ï¸  Skipping already processed transaction:', txHash);          return;        }        if (txHash) {          processedTransactions.add(txHash);        }        console.log('\nðŸ CampaignFinalized event detected');        console.log('Campaign ID:', campaignId.toString());        console.log('TX Hash:', txHash);        console.log('Total Raised:', ethers.formatEther(totalRaised), 'ETH');        console.log('Creator Amount:', ethers.formatEther(creatorAmount), 'ETH');        console.log('Platform Fee:', ethers.formatEther(platformFee), 'ETH');        const campaign = await Campaign.findOne({           blockchainId: Number(campaignId)         });        if (!campaign) {          console.warn('âš ï¸  Campaign not found in MongoDB');          return;        }        await campaign.finalizeCampaign();        console.log('âœ… Campaign finalized in MongoDB');      } catch (error) {        console.error('âŒ Error processing CampaignFinalized event:', error);      }    }  );  console.log('ðŸ‘‚ Listening to CampaignFinalized events...');}function listenToSkinPurchased() {  skinPaymentContract.on(    'SkinPurchased',    async (buyer, skinId, price, platformFee, event) => {      try {        const eventBlock = event.log?.blockNumber || event.blockNumber;        if (eventBlock && startBlock && eventBlock < startBlock) {          console.log('â­ï¸  Ignoring historical event from block', eventBlock);          return;        }        const txHash = event.log?.transactionHash || event.transactionHash;        if (txHash && processedTransactions.has(txHash)) {          console.log('â­ï¸  Skipping already processed transaction:', txHash);          return;        }        if (txHash) {          processedTransactions.add(txHash);        }        console.log('\nðŸ›ï¸  SkinPurchased event detected');        console.log('Buyer:', buyer);        console.log('Skin ID:', skinId.toString());        console.log('TX Hash:', txHash);        console.log('Price:', ethers.formatEther(price), 'STM');        console.log('Platform Fee:', ethers.formatEther(platformFee), 'STM');        const skin = await Skin.findOne({ tokenId: Number(skinId) });        if (!skin) {          console.warn('âš ï¸  Skin with tokenId', skinId.toString(), 'not found in MongoDB');          return;        }        let user = await User.findOne({           walletAddress: buyer.toLowerCase()         });        if (!user) {          console.warn('âš ï¸  User not found for wallet:', buyer);          user = new User({            email: `${buyer.toLowerCase()}@anonymous.com`,            password: 'anonymous',            walletAddress: buyer.toLowerCase()          });          await user.save();          console.log('âœ… Created anonymous user for wallet');        }        if (user.ownsSkin(skin._id)) {          console.log('âš ï¸  User already owns this skin');          return;        }        await user.addSkin(skin._id);        await skin.addOwner(user._id);        console.log('âœ… Skin ownership updated in MongoDB');        console.log(`   User ${user.email} now owns ${skin.name}`);      } catch (error) {        console.error('âŒ Error processing SkinPurchased event:', error);      }    }  );  console.log('ðŸ‘‚ Listening to SkinPurchased events...');}async function startListening() {  if (isListening) {    console.warn('âš ï¸  Already listening to blockchain events');    return;  }  try {    await provider.getNetwork();    initializeContracts();    if (crowdfundingContract) {      crowdfundingContract.removeAllListeners();    }    if (skinPaymentContract) {      skinPaymentContract.removeAllListeners();    }    startBlock = await provider.getBlockNumber();    console.log(`ðŸ“ Starting event listeners from block ${startBlock} (ignoring historical events)`);    processedTransactions.clear();    listenToCampaignCreated();    listenToCampaignFunded();    listenToCampaignFinalized();    listenToSkinPurchased();    isListening = true;    console.log('\nâœ… Blockchain listener service started successfully\n');  } catch (error) {    console.error('âŒ Failed to start blockchain listener:', error.message);    throw error;  }}function stopListening() {  if (!isListening) {    return;  }  try {    if (crowdfundingContract) {      crowdfundingContract.removeAllListeners();    }    if (skinPaymentContract) {      skinPaymentContract.removeAllListeners();    }    isListening = false;    console.log('ðŸ›‘ Blockchain listener service stopped');  } catch (error) {    console.error('âŒ Error stopping blockchain listener:', error);  }}async function syncPastEvents(fromBlock = 0) {  try {    console.log('ðŸ”„ Syncing past events from block', fromBlock);    const currentBlock = await provider.getBlockNumber();    console.log('Current block:', currentBlock);    const campaignCreatedFilter = crowdfundingContract.filters.CampaignCreated();    const campaignCreatedEvents = await crowdfundingContract.queryFilter(      campaignCreatedFilter,      fromBlock,      currentBlock    );    console.log(`Found ${campaignCreatedEvents.length} CampaignCreated events`);    const skinPurchasedFilter = skinPaymentContract.filters.SkinPurchased();    const skinPurchasedEvents = await skinPaymentContract.queryFilter(      skinPurchasedFilter,      fromBlock,      currentBlock    );    console.log(`Found ${skinPurchasedEvents.length} SkinPurchased events`);    console.log('âœ… Past events synced');  } catch (error) {    console.error('âŒ Error syncing past events:', error);  }}process.on('SIGINT', () => {  console.log('\nðŸ›‘ Shutting down blockchain listener...');  stopListening();  process.exit(0);});process.on('SIGTERM', () => {  console.log('\nðŸ›‘ Shutting down blockchain listener...');  stopListening();  process.exit(0);});module.exports = {  startListening,  stopListening,  syncPastEvents};