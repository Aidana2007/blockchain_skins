const { ethers } = require('ethers');const { getContract, getContractWithSigner, addresses } = require('../config/blockchain');async function getSTMBalance(address) {  try {    const steamTokenContract = getContract('steamToken');    const balance = await steamTokenContract.balanceOf(address);    return ethers.formatEther(balance);  } catch (error) {    console.error('Error getting STM balance:', error);    throw error;  }}async function getETHBalance(address) {  try {    const { provider } = require('../config/blockchain');    const balance = await provider.getBalance(address);    return ethers.formatEther(balance);  } catch (error) {    console.error('Error getting ETH balance:', error);    throw error;  }}async function checkSTMApproval(ownerAddress) {  try {    const steamTokenContract = getContract('steamToken');    const allowance = await steamTokenContract.allowance(      ownerAddress,      addresses.skinPayment    );    return ethers.formatEther(allowance);  } catch (error) {    console.error('Error checking STM approval:', error);    throw error;  }}async function getCampaignFromBlockchain(campaignId) {  try {    const crowdfundingContract = getContract('crowdfunding');    const campaign = await crowdfundingContract.getCampaign(campaignId);    return {      title: campaign[0],      goal: ethers.formatEther(campaign[1]),      deadline: new Date(Number(campaign[2]) * 1000),      amountRaised: ethers.formatEther(campaign[3]),      creator: campaign[4],      finalized: campaign[5],      cancelled: campaign[6]    };  } catch (error) {    console.error('Error getting campaign from blockchain:', error);    throw error;  }}async function getUserContribution(campaignId, userAddress) {  try {    const crowdfundingContract = getContract('crowdfunding');    const contribution = await crowdfundingContract.getContribution(      campaignId,      userAddress    );    return ethers.formatEther(contribution);  } catch (error) {    console.error('Error getting user contribution:', error);    throw error;  }}async function isCampaignActive(campaignId) {  try {    const crowdfundingContract = getContract('crowdfunding');    return await crowdfundingContract.isCampaignActive(campaignId);  } catch (error) {    console.error('Error checking campaign status:', error);    throw error;  }}async function getCampaignCount() {  try {    const crowdfundingContract = getContract('crowdfunding');    const count = await crowdfundingContract.campaignCount();    return Number(count);  } catch (error) {    console.error('Error getting campaign count:', error);    throw error;  }}async function calculateSkinPrice(basePrice) {  try {    const skinPaymentContract = getContract('skinPayment');    const priceWei = ethers.parseEther(basePrice.toString());    const [totalPrice, platformFee] = await skinPaymentContract.calculatePrice(priceWei);    return {      totalPrice: ethers.formatEther(totalPrice),      platformFee: ethers.formatEther(platformFee)    };  } catch (error) {    console.error('Error calculating skin price:', error);    throw error;  }}async function canAffordSkin(userAddress, skinPrice) {  try {    const skinPaymentContract = getContract('skinPayment');    const priceWei = ethers.parseEther(skinPrice.toString());    return await skinPaymentContract.canAffordSkin(userAddress, priceWei);  } catch (error) {    console.error('Error checking affordability:', error);    throw error;  }}async function getTokenInfo() {  try {    const steamTokenContract = getContract('steamToken');    const [name, symbol, decimals] = await Promise.all([      steamTokenContract.name(),      steamTokenContract.symbol(),      steamTokenContract.decimals()    ]);    return { name, symbol, decimals: Number(decimals) };  } catch (error) {    console.error('Error getting token info:', error);    throw error;  }}function getContractAddresses() {  return { ...addresses };}async function verifyContracts() {  try {    const { provider } = require('../config/blockchain');    for (const [name, address] of Object.entries(addresses)) {      if (!address) {        console.warn(`${name} address not set`);        return false;      }      const code = await provider.getCode(address);      if (code === '0x') {        console.warn(`No contract code at ${name} address`);        return false;      }    }    return true;  } catch (error) {    console.error('Error verifying contracts:', error);    return false;  }}function formatAmount(amount) {  return ethers.formatEther(amount);}function parseAmount(amount) {  return ethers.parseEther(amount.toString());}module.exports = {  getSTMBalance,  getETHBalance,  checkSTMApproval,  getCampaignFromBlockchain,  getUserContribution,  isCampaignActive,  getCampaignCount,  calculateSkinPrice,  canAffordSkin,  getTokenInfo,  getContractAddresses,  verifyContracts,  formatAmount,  parseAmount};