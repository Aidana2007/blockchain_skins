const mongoose = require('mongoose');const campaignSchema = new mongoose.Schema({  title: {    type: String,    required: [true, 'Campaign title is required'],    trim: true  },  goal: {    type: Number,    required: [true, 'Funding goal is required'],    min: [0, 'Goal cannot be negative']  },  deadline: {    type: Date,    required: [true, 'Deadline is required']  },  amountRaised: {    type: Number,    default: 0,    min: [0, 'Amount raised cannot be negative']  },  creator: {    type: mongoose.Schema.Types.ObjectId,    ref: 'User',    required: false,    default: null  },  creatorWalletAddress: {    type: String,    required: true,    lowercase: true  },  blockchainId: {    type: Number,    required: true,    unique: true  },  txHash: {    type: String,    required: false  },  contributors: [{    user: {      type: mongoose.Schema.Types.ObjectId,      ref: 'User'    },    walletAddress: String,    amount: Number,    tokensRewarded: Number,    contributedAt: {      type: Date,      default: Date.now    }  }],  status: {    type: String,    enum: ['Active', 'Ended', 'Finalized', 'Cancelled'],    default: 'Active'  },  finalized: {    type: Boolean,    default: false  },  finalizedAt: {    type: Date  },  description: {    type: String,    trim: true  },  createdAt: {    type: Date,    default: Date.now  }}, {  timestamps: true});campaignSchema.index({ blockchainId: 1 }, { unique: true });campaignSchema.index({ creator: 1 });campaignSchema.index({ status: 1 });campaignSchema.index({ deadline: 1 });campaignSchema.virtual('progressPercent').get(function() {  if (this.goal === 0) return 0;  return Math.min((this.amountRaised / this.goal) * 100, 100);});campaignSchema.virtual('daysRemaining').get(function() {  const now = new Date();  const diff = this.deadline - now;  return Math.max(Math.ceil(diff / (1000 * 60 * 60 * 24)), 0);});campaignSchema.virtual('isActive').get(function() {  return this.status === 'Active' && new Date() < this.deadline;});campaignSchema.virtual('contributorCount').get(function() {  return this.contributors.length;});campaignSchema.virtual('goalETH').get(function() {  return this.goal;});campaignSchema.virtual('raisedETH').get(function() {  return this.amountRaised;});campaignSchema.virtual('contributorsCount').get(function() {  return this.contributors?.length || 0;});campaignSchema.methods.addContribution = async function(userId, walletAddress, amount, tokensRewarded) {  this.contributors.push({    user: userId,    walletAddress,    amount,    tokensRewarded,    contributedAt: new Date()  });  this.amountRaised += amount;  await this.save();};campaignSchema.methods.finalizeCampaign = async function() {  this.status = 'Finalized';  this.finalized = true;  this.finalizedAt = new Date();  await this.save();};campaignSchema.methods.updateStatus = async function() {  if (this.status === 'Active' && new Date() >= this.deadline) {    this.status = 'Ended';    await this.save();  }};campaignSchema.statics.getActiveCampaigns = function() {  return this.find({    status: 'Active',    deadline: { $gt: new Date() }  }).populate('creator', 'email walletAddress');};campaignSchema.statics.getCampaignsByCreator = function(creatorId) {  return this.find({ creator: creatorId })    .populate('contributors.user', 'email walletAddress');};campaignSchema.statics.getByBlockchainId = function(blockchainId) {  return this.findOne({ blockchainId });};campaignSchema.pre('save', async function() {  if (this.status === 'Active' && new Date() >= this.deadline) {    this.status = 'Ended';  }});campaignSchema.set('toJSON', { virtuals: true });campaignSchema.set('toObject', { virtuals: true });module.exports = mongoose.model('Campaign', campaignSchema);