const Campaign = require('../models/Campaign');const User = require('../models/User');const { getContract } = require('../config/blockchain');const { ethers } = require('ethers');const getAllCampaigns = async (req, res) => {  try {    const { status, creator } = req.query;    let filter = {};    if (status) {      filter.status = status;    }    if (creator) {      filter.creator = creator;    }    const campaigns = await Campaign.find(filter)      .populate('creator', 'email walletAddress')      .sort({ createdAt: -1 });    for (let campaign of campaigns) {      await campaign.updateStatus();    }    res.json({      success: true,      count: campaigns.length,      data: { campaigns }    });  } catch (error) {    console.error('Get campaigns error:', error);    res.status(500).json({      success: false,      message: 'Error fetching campaigns',      error: error.message    });  }};const getCampaignById = async (req, res) => {  try {    const campaign = await Campaign.findById(req.params.id)      .populate('creator', 'email walletAddress')      .populate('contributors.user', 'email walletAddress');    if (!campaign) {      return res.status(404).json({        success: false,        message: 'Campaign not found'      });    }    await campaign.updateStatus();    res.json({      success: true,      data: { campaign }    });  } catch (error) {    console.error('Get campaign error:', error);    res.status(500).json({      success: false,      message: 'Error fetching campaign',      error: error.message    });  }};const getCampaignByBlockchainId = async (req, res) => {  try {    const campaign = await Campaign.getByBlockchainId(      parseInt(req.params.blockchainId)    ).populate('creator', 'email walletAddress');    if (!campaign) {      return res.status(404).json({        success: false,        message: 'Campaign not found'      });    }    res.json({      success: true,      data: { campaign }    });  } catch (error) {    console.error('Get campaign by blockchain ID error:', error);    res.status(500).json({      success: false,      message: 'Error fetching campaign',      error: error.message    });  }};const getActiveCampaigns = async (req, res) => {  try {    const campaigns = await Campaign.getActiveCampaigns();    res.json({      success: true,      count: campaigns.length,      data: { campaigns }    });  } catch (error) {    console.error('Get active campaigns error:', error);    res.status(500).json({      success: false,      message: 'Error fetching active campaigns',      error: error.message    });  }};const getCampaignsByCreator = async (req, res) => {  try {    const campaigns = await Campaign.getCampaignsByCreator(req.params.userId);    res.json({      success: true,      count: campaigns.length,      data: { campaigns }    });  } catch (error) {    console.error('Get campaigns by creator error:', error);    res.status(500).json({      success: false,      message: 'Error fetching campaigns',      error: error.message    });  }};const getMyCampaigns = async (req, res) => {  try {    const campaigns = await Campaign.getCampaignsByCreator(req.user.id);    res.json({      success: true,      count: campaigns.length,      data: { campaigns }    });  } catch (error) {    console.error('Get my campaigns error:', error);    res.status(500).json({      success: false,      message: 'Error fetching campaigns',      error: error.message    });  }};const getCampaignBlockchainData = async (req, res) => {  try {    const campaign = await Campaign.findById(req.params.id);    if (!campaign) {      return res.status(404).json({        success: false,        message: 'Campaign not found'      });    }    const crowdfundingContract = getContract('crowdfunding');    const blockchainData = await crowdfundingContract.getCampaign(      campaign.blockchainId    );    const [title, goal, deadline, amountRaised, creator, finalized, cancelled] = blockchainData;    res.json({      success: true,      data: {        blockchainId: campaign.blockchainId,        title,        goal: ethers.formatEther(goal),        deadline: new Date(Number(deadline) * 1000),        amountRaised: ethers.formatEther(amountRaised),        creator,        finalized,        cancelled      }    });  } catch (error) {    console.error('Get blockchain data error:', error);    res.status(500).json({      success: false,      message: 'Error fetching blockchain data',      error: error.message    });  }};const getUserContribution = async (req, res) => {  try {    const { id, walletAddress } = req.params;    const campaign = await Campaign.findById(id);    if (!campaign) {      return res.status(404).json({        success: false,        message: 'Campaign not found'      });    }    const crowdfundingContract = getContract('crowdfunding');    const contribution = await crowdfundingContract.getContribution(      campaign.blockchainId,      walletAddress    );    res.json({      success: true,      data: {        walletAddress,        contribution: ethers.formatEther(contribution),        contributionWei: contribution.toString()      }    });  } catch (error) {    console.error('Get contribution error:', error);    res.status(500).json({      success: false,      message: 'Error fetching contribution',      error: error.message    });  }};const syncCampaignFromBlockchain = async (req, res) => {  try {    const campaign = await Campaign.findById(req.params.id);    if (!campaign) {      return res.status(404).json({        success: false,        message: 'Campaign not found'      });    }    const crowdfundingContract = getContract('crowdfunding');    const blockchainData = await crowdfundingContract.getCampaign(      campaign.blockchainId    );    const [title, goal, deadline, amountRaised, creator, finalized, cancelled] = blockchainData;    campaign.title = title;    campaign.goal = Number(ethers.formatEther(goal));    campaign.deadline = new Date(Number(deadline) * 1000);    campaign.amountRaised = Number(ethers.formatEther(amountRaised));    campaign.finalized = finalized;    if (finalized) {      campaign.status = 'Finalized';    } else if (cancelled) {      campaign.status = 'Cancelled';    } else if (new Date() >= campaign.deadline) {      campaign.status = 'Ended';    } else {      campaign.status = 'Active';    }    await campaign.save();    res.json({      success: true,      message: 'Campaign synced from blockchain',      data: { campaign }    });  } catch (error) {    console.error('Sync campaign error:', error);    res.status(500).json({      success: false,      message: 'Error syncing campaign',      error: error.message    });  }};const createCampaign = async (req, res) => {  try {    console.log('üìù Create campaign request:', req.body);    const { title, goalETH, durationDays, blockchainId, txHash } = req.body;    const blockchainIdValue = blockchainId !== undefined && blockchainId !== null && blockchainId !== ''      ? Number(blockchainId)      : null;    if (!req.user || !req.user._id) {      console.log('‚ùå No authenticated user on request');      return res.status(401).json({        success: false,        message: 'Not authorized to create campaign'      });    }    if (!title || !goalETH || !durationDays) {      return res.status(400).json({        success: false,        message: 'Please provide title, goalETH, and durationDays'      });    }    const deadline = new Date();    deadline.setDate(deadline.getDate() + parseInt(durationDays));    if (blockchainIdValue === null || Number.isNaN(blockchainIdValue)) {      return res.status(400).json({        success: false,        message: 'Missing blockchainId from transaction receipt. Please retry after confirming the transaction succeeded.'      });    }    console.log('Creating campaign with:', {      title,      goal: parseFloat(goalETH),      deadline,      creator: req.user._id,      creatorWalletAddress: req.user.walletAddress,      blockchainId: blockchainIdValue,      txHash    });    const upsertResult = await Campaign.findOneAndUpdate(      { blockchainId: blockchainIdValue },      {        $setOnInsert: {          title,          goal: parseFloat(goalETH),          deadline,          creator: req.user._id,          creatorWalletAddress: req.user.walletAddress.toLowerCase(),          blockchainId: blockchainIdValue,          txHash: txHash || null,          status: 'Active',          amountRaised: 0        }      },      {         upsert: true,         new: true,        setDefaultsOnInsert: true       }    );    const isNewCampaign = upsertResult && !upsertResult.txHash;    if (isNewCampaign) {      console.log('‚úÖ Campaign created via API:', upsertResult._id);      if (req.user?._id) {        await User.findByIdAndUpdate(          req.user._id,          { $addToSet: { createdCampaigns: upsertResult._id } }        );      }    } else {      console.log('‚ÑπÔ∏è Campaign already existed, returning existing:', upsertResult._id);    }    res.status(isNewCampaign ? 201 : 200).json({      success: true,      message: isNewCampaign ? 'Campaign created successfully' : 'Campaign already exists',      data: { campaign: upsertResult }    });  } catch (error) {    if (error.code === 11000 && error.keyPattern && error.keyPattern.blockchainId) {      console.warn('‚ö†Ô∏è Duplicate blockchainId detected, returning existing');      const existing = await Campaign.findOne({ blockchainId: blockchainIdValue });      if (existing) {        return res.status(200).json({          success: true,          message: 'Campaign already exists',          data: { campaign: existing }        });      }    }    console.error('‚ùå Create campaign error:', error);    console.error('Error stack:', error.stack);    res.status(500).json({      success: false,      message: 'Error creating campaign',      error: error.message    });  }};module.exports = {  getAllCampaigns,  getCampaignById,  getCampaignByBlockchainId,  getActiveCampaigns,  getCampaignsByCreator,  getMyCampaigns,  getCampaignBlockchainData,  getUserContribution,  syncCampaignFromBlockchain,  createCampaign};